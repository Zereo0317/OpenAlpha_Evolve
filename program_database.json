{
    "generic_shortest_path_problem_gen0_prog0": {
        "id": "generic_shortest_path_problem_gen0_prog0",
        "code": "",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 11.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 0,
        "errors": [
            "Failed 11 of 11 tests at Level 0 ('default_level')."
        ],
        "status": "failed_evaluation",
        "created_at": 1749281112.733123,
        "task_id": null
    },
    "generic_shortest_path_problem_gen0_prog1": {
        "id": "generic_shortest_path_problem_gen0_prog1",
        "code": "import heapq\n\ndef solve_shortest_paths(graph, start_node):\n    # 1. Collect all unique nodes in the graph\n    # This ensures all nodes, even those only appearing as destinations, are included.\n    all_nodes = set()\n    all_nodes.add(start_node)\n    for node, edges in graph.items():\n        all_nodes.add(node)\n        for neighbor in edges:\n            all_nodes.add(neighbor)\n\n    # 2. Initialize distances\n    # All nodes start with an infinite distance, except the start_node which is 0.\n    distances = {node: float('inf') for node in all_nodes}\n    distances[start_node] = 0\n\n    # 3. Priority queue (min-heap)\n    # Stores tuples of (distance, node) to efficiently retrieve the node with the smallest distance.\n    priority_queue = [(0, start_node)]\n\n    # 4. Dijkstra's Algorithm\n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n\n        # If we've already found a shorter path to this node, skip processing it.\n        # This handles cases where a node is pushed multiple times with different distances,\n        # but we only care about the shortest one.\n        if current_distance > distances[current_node]:\n            continue\n\n        # Explore neighbors of the current_node\n        # Ensure current_node exists as a key in the graph before iterating its edges.\n        # A node might be in `all_nodes` (e.g., a destination or the start_node) but not\n        # have any outgoing edges defined in the `graph` dictionary.\n        if current_node in graph:\n            for neighbor, weight in graph[current_node].items():\n                distance = current_distance + weight\n\n                # If a shorter path to the neighbor is found through current_node\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n    return distances",
        "fitness_scores": {
            "correctness": 0.7272727272727273,
            "runtime_ms": Infinity,
            "passed_tests": 8.0,
            "total_tests": 11.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [
            "Failed 3 of 11 tests at Level 0 ('default_level')."
        ],
        "status": "failed_evaluation",
        "created_at": 1749281112.733737,
        "task_id": null
    },
    "generic_shortest_path_problem_gen0_prog2": {
        "id": "generic_shortest_path_problem_gen0_prog2",
        "code": "",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 11.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 2,
        "errors": [
            "Failed 11 of 11 tests at Level 0 ('default_level')."
        ],
        "status": "failed_evaluation",
        "created_at": 1749281112.7340338,
        "task_id": null
    },
    "generic_shortest_path_problem_gen0_prog3": {
        "id": "generic_shortest_path_problem_gen0_prog3",
        "code": "import heapq\n\ndef solve_shortest_paths(graph, start_node):\n    \"\"\"\n    Finds the shortest distance from a starting node to all other nodes in a\n    weighted, directed graph using Dijkstra's algorithm.\n\n    Args:\n        graph (dict): A dictionary representing the graph. Keys are node\n                      identifiers, and values are dictionaries of outgoing\n                      edges. In these inner dictionaries, keys are neighbor\n                      node identifiers and values are the weights (costs)\n                      of the edges.\n        start_node: The identifier of the starting node.\n\n    Returns:\n        dict: A dictionary where keys are node identifiers and values are the\n              calculated shortest distances from the start node. Unreachable\n              nodes will have a distance of float('inf').\n    \"\"\"\n    # 1. Gather all unique nodes in the graph.\n    # This includes nodes that are keys in the graph dictionary,\n    # and nodes that only appear as destinations of edges.\n    all_nodes = set()\n    for u in graph:\n        all_nodes.add(u)\n        for v in graph[u]:\n            all_nodes.add(v)\n    \n    # Ensure the start_node is included in the set of all nodes,\n    # even if the graph is empty or the start_node is isolated.\n    all_nodes.add(start_node)\n\n    # 2. Initialize distances for all nodes.\n    # All distances are set to infinity, except for the start_node, which is 0.\n    distances = {node: float('inf') for node in all_nodes}\n    distances[start_node] = 0\n\n    # 3. Initialize a min-priority queue.\n    # The priority queue stores tuples of (distance, node), ordered by distance.\n    # We start with the start_node and its distance 0.\n    priority_queue = [(0, start_node)]\n\n    # 4. Dijkstra's algorithm main loop.\n    while priority_queue:\n        # Extract the node with the smallest known distance.\n        current_distance, u = heapq.heappop(priority_queue)\n\n        # If we have already found a shorter path to 'u', skip this one.\n        # This handles redundant entries in the heap.\n        if current_distance > distances[u]:\n            continue\n\n        # Explore neighbors of 'u'.\n        # Check if 'u' actually exists as a key in the graph dictionary,\n        # as some nodes might be destinations only and not have outgoing edges defined.\n        if u in graph:\n            for v, weight in graph[u].items():\n                # Calculate the distance to the neighbor 'v' through 'u'.\n                distance = current_distance + weight\n\n                # If a shorter path to 'v' is found, update its distance\n                # and add it to the priority queue.\n                if distance < distances[v]:\n                    distances[v] = distance\n                    heapq.heappush(priority_queue, (distance, v))\n    \n    return distances",
        "fitness_scores": {
            "correctness": 0.7272727272727273,
            "runtime_ms": Infinity,
            "passed_tests": 8.0,
            "total_tests": 11.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [
            "Failed 3 of 11 tests at Level 0 ('default_level')."
        ],
        "status": "failed_evaluation",
        "created_at": 1749281112.734483,
        "task_id": null
    },
    "generic_shortest_path_problem_gen0_prog4": {
        "id": "generic_shortest_path_problem_gen0_prog4",
        "code": "",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 11.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 3,
        "errors": [
            "Failed 11 of 11 tests at Level 0 ('default_level')."
        ],
        "status": "failed_evaluation",
        "created_at": 1749281112.736507,
        "task_id": null
    },
    "generic_shortest_path_problem_gen1_child0_0": {
        "id": "generic_shortest_path_problem_gen1_child0_0",
        "code": "def solve_shortest_paths(graph, start):\n    import heapq\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    pq = [(0, start)]\n\n    while pq:\n        curr_dist, curr_node = heapq.heappop(pq)\n\n        if curr_dist > distances[curr_node]:\n            continue\n\n        for neighbor, weight in graph.get(curr_node, {}).items():\n            distance = curr_dist + weight\n                        if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    for node in distances:\n        if distances[node] == float('inf'):\n            distances[node] = \"float('inf')\"\n\n    return distances",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog0",
        "island_id": 0,
        "errors": [
            "SyntaxError: unexpected indent at line 17, offset 24"
        ],
        "status": "failed_evaluation",
        "created_at": 1748342488.4308155,
        "task_id": null
    },
    "generic_shortest_path_problem_gen1_child0_1": {
        "id": "generic_shortest_path_problem_gen1_child0_1",
        "code": "def solve_shortest_paths(graph, start):\n    import heapq\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    pq = [(0, start)]\n\n    while pq:\n        curr_dist, curr_node = heapq.heappop(pq)\n\n        if curr_dist > distances[curr_node]:\n            continue\n\n        for neighbor, weight in graph.get(curr_node, {}).items():\n            distance = curr_dist + weight\n                        if distance < distances[neighbor]:\n                heapq.heappush(pq, (distance, neighbor))\n                distances[neighbor] = distance\n\n    for node in distances:\n        if distances[node] == float('inf'):\n            distances[node] = \"float('inf')\"\n\n    return distances",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog0",
        "island_id": 0,
        "errors": [
            "SyntaxError: unexpected indent at line 17, offset 24"
        ],
        "status": "failed_evaluation",
        "created_at": 1748342488.7255383,
        "task_id": null
    },
    "generic_shortest_path_problem_gen1_child0_2": {
        "id": "generic_shortest_path_problem_gen1_child0_2",
        "code": "def solve_shortest_paths(graph, start):\n    import heapq\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    pq = [(0, start)]\n\n    while pq:\n        curr_dist, curr_node = heapq.heappop(pq)\n\n        if curr_dist > distances[curr_node]:\n            continue\n\n        for neighbor, weight in graph.get(curr_node, {}).items():\n            distance = curr_dist + weight\n                        if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n            else:\n                heapq.heappush(pq, (distances[neighbor], neighbor))\n\n    for node in distances:\n        if distances[node] == float('inf'):\n            distances[node] = \"float('inf')\"\n\n    return distances",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog0",
        "island_id": 0,
        "errors": [
            "SyntaxError: unexpected indent at line 17, offset 24"
        ],
        "status": "failed_evaluation",
        "created_at": 1748342489.0236142,
        "task_id": null
    },
    "generic_shortest_path_problem_gen1_child1_0": {
        "id": "generic_shortest_path_problem_gen1_child1_0",
        "code": "import heapq\n\ndef solve_shortest_paths(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n    heap = [(0, start)]\n\n    while heap:\n        (curr_dist, curr_node) = heapq.heappop(heap)\n\n        if curr_node in visited:\n            continue\n\n        visited.add(curr_node)\n\n        for neighbor, weight in graph.get(curr_node, {}).items():\n            new_dist = curr_dist + weight\n                        if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(heap, (new_dist, neighbor))\n\n    for node in graph:\n        if distances[node] == float('inf'):\n            distances[node] = \"float('inf')\"\n\n    return distances",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog1",
        "island_id": 1,
        "errors": [
            "SyntaxError: unexpected indent at line 19, offset 24"
        ],
        "status": "failed_evaluation",
        "created_at": 1748342488.415723,
        "task_id": null
    },
    "generic_shortest_path_problem_gen1_child1_1": {
        "id": "generic_shortest_path_problem_gen1_child1_1",
        "code": "import heapq\n\ndef solve_shortest_paths(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n    heap = [(0, start)]\n\n    while heap:\n        (curr_dist, curr_node) = heapq.heappop(heap)\n\n        if curr_node in visited:\n            continue\n\n        visited.add(curr_node)\n\n        for neighbor, weight in graph.get(curr_node, {}).items():\n            new_dist = curr_dist + weight\n                        if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(heap, (new_dist, neighbor))\n            else:\n                heapq.heappush(heap, (distances[neighbor], neighbor))\n\n    for node in graph:\n        if distances[node] == float('inf'):\n            distances[node] = \"float('inf')\"\n\n    return distances",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog1",
        "island_id": 1,
        "errors": [
            "SyntaxError: unexpected indent at line 19, offset 24"
        ],
        "status": "failed_evaluation",
        "created_at": 1748342489.2366982,
        "task_id": null
    },
    "generic_shortest_path_problem_gen1_child1_2": {
        "id": "generic_shortest_path_problem_gen1_child1_2",
        "code": "import heapq\n\ndef solve_shortest_paths(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n    heap = [(0, start)]\n\n    while heap:\n        (curr_dist, curr_node) = heapq.heappop(heap)\n\n        if curr_node in visited:\n            continue\n\n        visited.add(curr_node)\n\n                for neighbor, weight in graph.get(curr_node, {}).items():\n            new_dist = curr_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(heap, (new_dist, neighbor))\n\n    for node in graph:\n        if distances[node] == float('inf'):\n            distances[node] = \"float('inf')\"\n\n    return distances",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 1,
        "parent_id": "generic_shortest_path_problem_gen0_prog1",
        "island_id": 1,
        "errors": [
            "SyntaxError: unexpected indent at line 17, offset 16"
        ],
        "status": "failed_evaluation",
        "created_at": 1748342489.7421393,
        "task_id": null
    },
    "generic_shortest_path_problem_gen2_child0_0": {
        "id": "generic_shortest_path_problem_gen2_child0_0",
        "code": "def solve_shortest_paths(graph, start):\n    import heapq\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    pq = [(0, start)]\n\n    while pq:\n        curr_dist, curr_node = heapq.heappop(pq)\n\n                if curr_dist >= distances[curr_node]:\n            continue\n\n        for neighbor, weight in graph.get(curr_node, {}).items():\n            distance = curr_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    for node in distances:\n        if distances[node] == float('inf'):\n                        distances[node] = float('inf')\n\n    return distances",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog0",
        "island_id": 0,
        "errors": [
            "SyntaxError: unexpected indent at line 12, offset 16"
        ],
        "status": "failed_evaluation",
        "created_at": 1748342491.2883773,
        "task_id": null
    },
    "generic_shortest_path_problem_gen2_child0_2": {
        "id": "generic_shortest_path_problem_gen2_child0_2",
        "code": "def solve_shortest_paths(graph, start):\n    import heapq\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    pq = [(0, start)]\n\n    while pq:\n        curr_dist, curr_node = heapq.heappop(pq)\n\n        if curr_dist > distances[curr_node]:\n            continue\n\n        for neighbor, weight in graph.get(curr_node, {}).items():\n            distance = curr_dist + weight\n                        if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n            else:\n                heapq.heappush(pq, (distances[neighbor], neighbor))\n\n    for node in distances:\n        if distances[node] == float('inf'):\n            distances[node] = \"float('inf')\"\n\n    return distances",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog0",
        "island_id": 0,
        "errors": [
            "SyntaxError: unexpected indent at line 17, offset 24"
        ],
        "status": "failed_evaluation",
        "created_at": 1748342491.588024,
        "task_id": null
    },
    "generic_shortest_path_problem_gen2_child1_0": {
        "id": "generic_shortest_path_problem_gen2_child1_0",
        "code": "import heapq\n\ndef solve_shortest_paths(graph, start_node):\n    if not graph:\n        if start_node is None:\n            return None\n        else:\n            return {start_node: 0}\n    \n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n        for neighbor in graph[node]:\n            if neighbor not in distances:\n                distances[neighbor] = float('inf')\n    \n    all_nodes = set(distances.keys())\n    for node in graph:\n        for neighbor in graph[node]:\n            if neighbor not in all_nodes:\n                all_nodes.add(neighbor)\n\n        \n    if start_node not in all_nodes:\n        all_nodes.add(start_node)\n\n    distances[start_node] = 0\n    pq = [(0, start_node)]  # Priority queue: (distance, node)\n\n    while pq:\n                dist, current_node = heapq.heappop(pq)\n\n        if dist > distances[current_node]:\n            continue\n\n        # Explore neighbors of the current node\n        if current_node in graph:\n            for neighbor, weight in graph[current_node].items():\n                new_dist = dist + weight\n                if new_dist < distances[neighbor]:\n                    distances[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, neighbor))\n\n    # Ensure all nodes have a distance, including unreachable ones\n    for node in all_nodes:\n        if node not in distances:\n            distances[node] = float('inf')  # Or some other default value\n\n    return distances",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog4",
        "island_id": 2,
        "errors": [
            "SyntaxError: unindent does not match any outer indentation level at line 33, offset 43"
        ],
        "status": "failed_evaluation",
        "created_at": 1748260462.465798,
        "task_id": null
    },
    "generic_shortest_path_problem_gen2_child1_1": {
        "id": "generic_shortest_path_problem_gen2_child1_1",
        "code": "import heapq\n\ndef solve_shortest_paths(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n    heap = [(0, start)]\n\n    while heap:\n        (curr_dist, curr_node) = heapq.heappop(heap)\n\n        if curr_node in visited:\n            continue\n\n        visited.add(curr_node)\n\n        for neighbor, weight in graph.get(curr_node, {}).items():\n            new_dist = curr_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(heap, (new_dist, neighbor))\n\n    for node in graph:\n        if distances[node] == float('inf'):\n                        distances[node] = float('inf')\n\n    return distances",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog1",
        "island_id": 1,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Unexpected execution error: [WinError 2] \u7cfb\u7d71\u627e\u4e0d\u5230\u6307\u5b9a\u7684\u6a94\u6848\u3002"
        ],
        "status": "failed_evaluation",
        "created_at": 1748342490.8700387,
        "task_id": null
    },
    "generic_shortest_path_problem_gen2_child1_2": {
        "id": "generic_shortest_path_problem_gen2_child1_2",
        "code": "import heapq\n\ndef solve_shortest_paths(graph, start_node):\n        distances = {}\n    all_nodes = set()\n\n    for node in graph:\n        distances[node] = float('inf')\n        all_nodes.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in distances:\n                distances[neighbor] = float('inf')\n                all_nodes.add(neighbor)\n    \n    if start_node is not None and start_node not in distances:\n        distances[start_node] = float('inf')\n        all_nodes.add(start_node)\n    elif start_node is None:\n        return {node: float('inf') for node in all_nodes} if all_nodes else {}\n    \n    distances[start_node] = 0\n    pq = [(0, start_node)]\n\n    while pq:\n        dist, current_node = heapq.heappop(pq)\n        \n        if dist > distances[current_node]:\n            continue\n\n        if current_node in graph:\n            for neighbor, weight in graph[current_node].items():\n                if distances[current_node] + weight < distances[neighbor]:\n                    distances[neighbor] = distances[current_node] + weight\n                    heapq.heappush(pq, (distances[neighbor], neighbor))\n                    \n    result = {}\n    for node in all_nodes:\n        result[node] = distances.get(node, float('inf'))\n\n    if start_node is not None and start_node not in result:\n        return None\n    \n    return result",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog4",
        "island_id": 2,
        "errors": [
            "SyntaxError: unindent does not match any outer indentation level at line 5, offset 22"
        ],
        "status": "failed_evaluation",
        "created_at": 1748260463.5454998,
        "task_id": null
    },
    "generic_shortest_path_problem_gen2_child0_1": {
        "id": "generic_shortest_path_problem_gen2_child0_1",
        "code": "def solve_shortest_paths(graph, start):\n    import heapq\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n\n    pq = [(0, start)]\n\n    while pq:\n        curr_dist, curr_node = heapq.heappop(pq)\n\n        if curr_dist > distances[curr_node]:\n            continue\n\n        for neighbor, weight in graph.get(curr_node, {}).items():\n            distance = curr_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n        for node in distances:\n        if distances[node] == float('inf'):\n            distances[node] = float('inf')\n\n    return distances",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0
        },
        "generation": 2,
        "parent_id": "generic_shortest_path_problem_gen0_prog0",
        "island_id": 0,
        "errors": [
            "SyntaxError: expected an indented block after 'for' statement on line 21 at line 22, offset 9"
        ],
        "status": "failed_evaluation",
        "created_at": 1748342491.2983148,
        "task_id": null
    },
    "fibonacci_task_gen0_prog0": {
        "id": "fibonacci_task_gen0_prog0",
        "code": "def fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 0,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Unexpected execution error: [WinError 2] \u7cfb\u7d71\u627e\u4e0d\u5230\u6307\u5b9a\u7684\u6a94\u6848\u3002"
        ],
        "status": "failed_evaluation",
        "created_at": 1749288243.6053126,
        "task_id": null
    },
    "fibonacci_task_gen0_prog1": {
        "id": "fibonacci_task_gen0_prog1",
        "code": "def fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 1,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Unexpected execution error: [WinError 2] \u7cfb\u7d71\u627e\u4e0d\u5230\u6307\u5b9a\u7684\u6a94\u6848\u3002"
        ],
        "status": "failed_evaluation",
        "created_at": 1749288243.6209319,
        "task_id": null
    },
    "fibonacci_task_gen0_prog2": {
        "id": "fibonacci_task_gen0_prog2",
        "code": "def fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b",
        "fitness_scores": {
            "correctness": 0.0,
            "runtime_ms": Infinity,
            "passed_tests": 0.0,
            "total_tests": 0.0,
            "highest_level_passed": -1.0
        },
        "generation": 0,
        "parent_id": null,
        "island_id": 2,
        "errors": [
            "Execution Error at Level 0 ('default_level'): Unexpected execution error: [WinError 2] \u7cfb\u7d71\u627e\u4e0d\u5230\u6307\u5b9a\u7684\u6a94\u6848\u3002"
        ],
        "status": "failed_evaluation",
        "created_at": 1749288243.6260264,
        "task_id": null
    }
}